@using Syncfusion.Blazor.Schedule

<SfSchedule TValue="ShowData"
			Width="100%"
			Height="100vh"
			@bind-SelectedDate="CurrentDate"
			@bind-CurrentView="CurrentView"
			StartHour="@StartHour"
			EndHour="@EndHour"
			TimeFormat="h:mm tt"
			AllowDragAndDrop="false">

	<!-- Quick-info for EVENTS only -->
	<ScheduleQuickInfoTemplates TemplateType="TemplateType.Event">
	@* 	<FooterTemplate Context="context">
			@{
				var ev = context as ShowData;
			}
			@if (ev is not null)
			{
				@ev.Description
			}
		</FooterTemplate> *@
	</ScheduleQuickInfoTemplates>

	<!-- Group: Category -> Channel -->
	<ScheduleGroup Resources="@GroupData" />

	<ScheduleResources>
		<!-- IMPORTANT: Field names match properties on ShowData -->
		<ScheduleResource TItem="CategoryData" TValue="string"
						  DataSource="@Categories"
						  Field="CategoryId"
						  Title="Categories"
						  Name="Categories"
						  TextField="Text"
						  IdField="Id" />

		<ScheduleResource TItem="ChannelData" TValue="string"
						  DataSource="@Channels"
						  Field="ChannelId"
						  GroupIDField="CategoryId"
						  Title="Channels"
						  Name="Channels"
						  TextField="Text"
						  IdField="Id" />
	</ScheduleResources>

	<ScheduleViews>
		<ScheduleView Option="View.TimelineDay" MaxEventsPerRow="1" />
	</ScheduleViews>

	<!-- No custom field mapping needed because we use Subject/StartTime/EndTime -->
	<ScheduleEventSettings TValue="ShowData" DataSource="@Events"
						   AllowAdding="false" AllowEditing="false" AllowDeleting="false" />
</SfSchedule>


@code {
    private View CurrentView = View.TimelineDay;
    private DateTime CurrentDate;
    private string StartHour = "";
    private string EndHour = "";
    public string[] GroupData { get; set; } = { "Categories", "Channels" };

    private readonly List<CategoryData> Categories = new();
    private readonly List<ChannelData> Channels = new();
    private readonly List<ShowData> Events = new();

    // 10 canonical channel names per category (no "24/7")
    private static readonly Dictionary<string, List<string>> TopChannels = new(StringComparer.OrdinalIgnoreCase)
    {
        ["Entertainment"] = new() { "AMC", "Bravo", "Comedy Central", "Discovery Channel", "Disney Channel", "FX", "HGTV", "History", "TNT", "USA Network" },
        ["Kids"] = new() { "Cartoon Network", "Disney Junior", "Disney XD", "Nickelodeon", "Nick Jr", "Nicktoons", "Universal Kids", "Boomerang", "PBS Kids", "Discovery Family" },
        ["Locals"] = new() { "ABC", "CBS", "NBC", "FOX", "CW", "PBS", "MyNetworkTV", "MeTV", "Ion Mystery", "Antenna TV" },
        ["Movies"] = new() { "HBO", "HBO 2", "Cinemax", "Showtime", "Starz", "MoreMax", "Epix", "Epix Hits", "The Movie Channel", "Starz Edge" },
        ["Music"] = new() { "MTV", "MTV2", "VH1", "BET", "CMT", "AXS TV", "Music Choice", "Revolt", "Fuse", "MTV Live" },
        ["News"] = new() { "CNN", "Fox News", "MSNBC", "CNBC", "Bloomberg", "ABC News", "CBS News", "NBC News", "Newsmax", "The Weather Channel" },
        ["Other"] = new() { "BBC America", "Court TV", "GSN", "ION", "Reelz", "TBN", "Ion Plus", "Bounce TV", "Laff", "Comet" },
        ["Sports"] = new() { "ESPN", "ESPN2", "ESPNews", "ESPNU", "FS1", "FS2", "NFL Network", "NBA TV", "MLB Network", "NHL Network" }
    };

    // Title pools (category + generic)
    private static readonly Dictionary<string, string[]> CatTitles = new(StringComparer.OrdinalIgnoreCase)
    {
        ["Entertainment"] = new[] { "Classic Sitcoms", "Drama Hour", "Reality Night", "Standup Spotlight", "Prime Time Movie", "Fan Favorites" },
        ["Kids"] = new[] { "Cartoon Block", "Adventure Hour", "After School Fun", "Family Time", "Kids Classics", "Jr. Jams" },
        ["Locals"] = new[] { "Local News", "Community Spotlight", "Morning Show", "Evening Magazine", "Weekend Edition", "Hometown Stories" },
        ["Movies"] = new[] { "Feature Presentation", "Double Feature", "Director’s Cut", "Late Night Thriller", "Matinee", "Indie Showcase" },
        ["Music"] = new[] { "Video Countdown", "Live Sessions", "Artist Spotlight", "Top Hits Hour", "Throwback Jams", "Festival Rewind" },
        ["News"] = new[] { "Breaking Coverage", "Live Desk", "World Report", "Market Watch", "Investigative", "Weather Update" },
        ["Other"] = new[] { "Cult Classics", "Retro Hour", "Game Show Block", "Mystery Theater", "Viewer’s Choice", "Retro Sci-Fi" },
        ["Sports"] = new[] { "Live Match", "Game Rewind", "Highlights", "Pre-Game", "Post-Game", "Analysis Desk" }
    };
    private static readonly string[] GenericTitles =
        { "Morning Headlines","Midday Update","Afternoon Live","Prime Time Special","Late Night Talk",
          "Weekend Spotlight","Behind the Scenes","Documentary Deep Dive","Comedy Classics","Drama Showcase" };

    protected override void OnInitialized()
    {
        // Start now rounded to :00 or :30; window = 12 hours
        var now = DateTime.Now;
        var start = new DateTime(now.Year, now.Month, now.Day, now.Hour, (now.Minute < 30 ? 0 : 30), 0, DateTimeKind.Local);
        var end = start.AddHours(12);

        CurrentDate = start;
        StartHour = $"{start:HH:mm}";
        EndHour = $"{end:HH:mm}";

        BuildGuideData(start, end);
    }

    private void BuildGuideData(DateTime windowStart, DateTime windowEnd)
    {
        foreach (var kvp in TopChannels)
        {
            var categoryName = kvp.Key;

            var cat = new CategoryData
            {
                Id = Guid.NewGuid().ToString(),
                Text = categoryName,
                IsExpanded = true
            };
            Categories.Add(cat);

            foreach (var channelName in kvp.Value.Take(10))
            {
                var channel = new ChannelData
                {
                    Id = Guid.NewGuid().ToString(),
                    Text = channelName,
                    CategoryId = cat.Id
                };
                Channels.Add(channel);

                Events.AddRange(FillRandomSchedule(cat.Id, channel.Id, categoryName, channelName, windowStart, windowEnd));
            }
        }
    }

    // Build a randomized schedule per channel that fills [start, end)
    private IEnumerable<ShowData> FillRandomSchedule(string categoryId, string channelId, string categoryName, string channelName, DateTime start, DateTime end)
    {
        // Seed per (date, channel) so it’s consistent on a given day
        int seed = HashCode.Combine(start.Date, channelName);
        var rng = new Random(seed);

        // Optional small random offset at the first show (0, 10, 15, 20, or 30 mins)
        int[] firstOffsets = { 0, 10, 15, 20, 30 };
        var slotStart = start.AddMinutes(firstOffsets[rng.Next(firstOffsets.Length)]);

        if (slotStart > end)
        {
            slotStart = start;
        }

        while (slotStart < end)
        {
            int minutes = NextDuration(rng); // 30/60/90 with weights
            var slotEnd = slotStart.AddMinutes(minutes);
            if (slotEnd > end)
            {
                slotEnd = end;
            }

            string title = PickTitle(rng, categoryName, channelName);

            yield return new ShowData
            {
                Subject = $"{channelName} — {title}",
                Description = $"{minutes}-minute segment of {title} on {channelName}.",
                StartTime = slotStart,
                EndTime = slotEnd,
                ChannelId = channelId,
                CategoryId = categoryId
            };

            // small random inter-show gap (0–5 mins) to avoid perfect alignment sometimes
            int gap = rng.Next(0, 6);
            slotStart = slotEnd.AddMinutes(gap);
        }
    }

    // Weighted random: ~45% 30m, ~40% 60m, ~15% 90m
    private static int NextDuration(Random rng)
    {
        int roll = rng.Next(100); // 0..99
        if (roll < 45) { return 30; }
        if (roll < 85) { return 60; }
        { return 90; }
    }

    private static string PickTitle(Random rng, string categoryName, string channelName)
    {
        if (CatTitles.TryGetValue(categoryName, out var pool) && pool.Length > 0)
        {
            // 70% from category pool, 30% from generic
            if (rng.NextDouble() < 0.7)
            {
                return pool[rng.Next(pool.Length)];
            }
            else
            {
                return GenericTitles[rng.Next(GenericTitles.Length)];
            }
        }
        else
        {
            return GenericTitles[rng.Next(GenericTitles.Length)];
        }
    }

    // ----- models (remove if you already have them in a shared project) -----
    public sealed class CategoryData
    {
        public string Id { get; set; } = "";
        public string Text { get; set; } = "";
        public bool IsExpanded { get; set; } = true;
    }

    public sealed class ChannelData
    {
        public string Id { get; set; } = "";
        public string Text { get; set; } = "";
        public string CategoryId { get; set; } = "";
    }

    public sealed class ShowData
    {
        public string Subject { get; set; } = "";
        public DateTime StartTime { get; set; }
        public DateTime EndTime { get; set; }
        public string Description { get; set; } = "";
        public string ChannelId { get; set; } = "";
        public string CategoryId { get; set; } = "";
    }
}

